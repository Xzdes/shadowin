# Shadowin

Самодостаточное десктопное приложение на Rust с полностью кастомным графическим интерфейсом (GUI), отрисованным с нуля.

## О проекте

Shadowin — это эксперимент и доказательство концепции, что можно создать полнофункциональное, интерактивное десктопное приложение на чистом Rust, не полагаясь на тяжелые фреймворки (такие как Electron) или стандартные системные виджеты.

Основная философия проекта — **полный контроль**. Мы управляем каждым пикселем на экране. Весь интерфейс, от кнопок до полей ввода текста, является просто визуальным представлением внутреннего состояния приложения. Мы не используем готовые UI-компоненты; вместо этого мы рисуем их сами, используя графические примитивы.

Это позволяет создавать уникальные, быстрые и кроссплатформенные приложения, где вся логика — от обработки клика мыши до рендеринга текста — написана на безопасном и производительном языке Rust.

## Ключевые особенности

*   **Полностью кастомный рендеринг:** Все виджеты отрисовываются пиксель за пикселем в буфер кадра. Нет зависимости от системных UI-библиотек.
*   **Модульная архитектура UI:** Логика интерфейса разделена на три уровня:
    1.  **Главный цикл (`main.rs`):** Управляет окном, событиями и состоянием.
    2.  **UI-менеджер (`ui/mod.rs`):** Содержит и управляет всеми виджетами.
    3.  **Виджеты (`ui/widgets.rs`):** Индивидуальные UI-элементы, которые знают, как себя рисовать и обновлять.
*   **Управление состоянием:** Интерфейс является прямым отражением структуры `AppState`. Изменение данных в `AppState` немедленно отражается на экране при следующей перерисовке.
*   **Самописная библиотека виджетов:** Включает в себя:
    *   `Button`: Интерактивная кнопка с состояниями `Idle`, `Hovered`, `Pressed`.
    *   `TextInput`: Поле для ввода текста с управлением фокусом, вводом символов, Backspace и мигающим курсором.
    *   `TextPanel`: Панель для отображения динамического текста.
*   **Обработка событий:** Реализована полная обработка событий мыши (движение, клики) и клавиатуры (ввод текста, специальные клавиши).
*   **Корректная обработка координат:** Система правильно преобразует физические координаты окна в логические координаты нашего холста, что позволяет интерфейсу работать корректно при любом размере окна.

## Запуск проекта

1.  **Установите Rust:** Если у вас его нет, установите с помощью `rustup`.
2.  **Добавьте шрифт:**
    *   Создайте папку `assets` в корневой директории проекта.
    *   Поместите в нее любой шрифт в формате `.ttf` и переименуйте его в `font.ttf`.
3.  **Запустите:** В терминале, в корневой директории проекта, выполните команду:
    ```bash
    cargo run
    ```

## Архитектура кода

### `main.rs`

Это точка входа и сердце приложения. Его обязанности:
1.  **Инициализация:** Создает окно (`winit`), настраивает графический контекст для рисования (`pixels`) и загружает ресурсы (шрифт).
2.  **Управление состоянием:** Создает и владеет `AppState` — структурой, которая хранит все данные приложения (координаты мыши, текст, счетчики и т.д.).
3.  **Главный цикл событий (`event_loop`):**
    *   Прослушивает все системные события: движение мыши, клики, нажатия клавиш, изменение размера окна.
    *   Обновляет `AppState` на основе этих событий.
    *   Делегирует обработку UI-логики модулю `Ui`.
    *   Запрашивает перерисовку окна, когда это необходимо.

### `ui/mod.rs`

Это "мозг" нашего интерфейса.
1.  **Структура `Ui`:** Является контейнером для всех виджетов (кнопок, полей ввода и т.д.).
2.  **Инициализация UI:** В методе `Ui::new` создаются и размещаются все виджеты.
3.  **Делегирование:** Содержит методы, которые вызываются из `main.rs`:
    *   `handle_click()`: Определяет, по какому виджету кликнули, и управляет фокусом.
    *   `update_visuals()`: Обновляет визуальное состояние виджетов (например, эффект наведения на кнопку).
    *   `handle_key_event()`: Передает события клавиатуры активному полю ввода.
    *   `draw()`: Вызывает методы отрисовки для каждого виджета.

### `ui/widgets.rs`

Это "строительные блоки" нашего интерфейса.
1.  **Определение виджетов:** Здесь определены структуры для каждого виджета (`Button`, `TextInput`, `TextPanel`).
2.  **Внутренняя логика:** Каждый виджет инкапсулирует свою логику:
    *   **Состояние:** Хранит свое внутреннее состояние (например, `ButtonState` или `is_focused`).
    *   **Отрисовка:** Имеет метод `.draw()`, который знает, как нарисовать себя на экране в зависимости от своего текущего состояния.
    *   **Обновление:** Имеет методы для обновления своего состояния на основе ввода пользователя.

## Принцип работы (цикл кадра)

1.  **События:** `main.rs` получает пачку системных событий. Если это клик мыши, он немедленно вызывает `ui.handle_click()`, который обновляет фокус и возвращает ID нажатой кнопки. Логика приложения в `main.rs` реагирует на этот ID и изменяет данные в `AppState`.
2.  **Ожидание (`AboutToWait`):** Когда все события обработаны, вызывается этот блок. Здесь мы:
    *   Получаем актуальные координаты мыши.
    *   Вызываем `ui.update_visuals()`, чтобы все кнопки и другие элементы обновили свой внешний вид (например, подсветились под курсором).
    *   Вызываем `window.request_redraw()`, чтобы сообщить системе, что мы готовы рисовать новый кадр.
3.  **Отрисовка (`RedrawRequested`):**
    *   Система вызывает этот блок.
    *   Мы очищаем экран, заливая его фоновым цветом из `AppState`.
    *   Мы вызываем `ui.draw(&app_state, ...)` одним вызовом.
    *   `Ui` последовательно вызывает `.draw()` для каждого своего виджета.
    *   Каждый виджет рисует себя, используя данные из `AppState` (например, текст) и свое внутреннее состояние (например, цвет нажатой кнопки).
    *   Готовый кадр отправляется на экран.

Этот цикл повторяется непрерывно, создавая иллюзию живого, отзывчивого интерфейса.


### **Концепция: "Shadowin AI" — Живой, Эволюционирующий Интерфейс**

1.  **Разделение Ответственности:**
    *   **"Скелет" (Rust-код, то, что мы написали):** Наш код больше не отвечает за то, *как* выглядит кнопка. Он отвечает только за ее "физику" и "логику":
        *   Где она находится (координаты `x, y, width, height`).
        *   В каком она состоянии (`Idle`, `Hovered`, `Pressed`).
        *   Что происходит, когда на нее кликают.
    *   **"Кожа" (Нейросеть):** Нейросеть отвечает за визуальное представление. Она получает на вход "задание" от нашего Rust-кода и генерирует "картинку" для виджета.

2.  **Как это будет работать (Цикл кадра):**
    *   **Шаг 1: Обновление логики.** Наш `update` определяет, что кнопка "Submit" сейчас в состоянии `Hovered`.
    *   **Шаг 2: Формирование Промпта для ИИ.** Вместо того чтобы просто выбрать цвет, мы формируем текстовый промпт для нейросети, описывающий, что нужно нарисовать.
        *   **Промпт:** `"Нарисуй кнопку с текстом 'Submit', состояние - наведение курсора, стиль - темный киберпанк, неоновое свечение, основной цвет - синий, размер 200x60 пикселей"`
    *   **Шаг 3: Генерация Изображения.** Мы отправляем этот промпт в локально запущенную модель для генерации изображений (например, Stable Diffusion через API). Модель возвращает нам картинку кнопки размером 200x60 пикселей.
    *   **Шаг 4: Отрисовка.** Наш метод `draw` больше не рисует прямоугольники и текст. Он просто берет сгенерированное нейросетью изображение и "впечатывает" его в наш главный буфер кадра в нужных координатах.

### **Что это нам дает? Невероятные возможности:**

1.  **Бесконечная Кастомизация:**
    *   **Темы на лету:** Пользователь может просто написать в настройках: "сделай интерфейс в стиле стимпанк" или "хочу акварельный дизайн", и весь UI мгновенно преобразится.
    *   **Уникальность:** Каждое открытие приложения может генерировать слегка отличающийся, но консистентный UI. Ни у кого больше не будет такого же интерфейса.

2.  **Адаптивный и "Живой" UI:**
    *   **Контекстно-зависимый дизайн:** Кнопка "Удалить" может становиться более красной и "агрессивной", если пользователь пытается удалить важный файл. Кнопка "Сохранить" может "сиять", если есть несохраненные изменения.
    *   **"Настроение" приложения:** Интерфейс может меняться в зависимости от времени суток, погоды или даже музыки, которую слушает пользователь.

3.  **Персонализация на Уровне ДНК:**
    *   Нейросеть может обучаться на предпочтениях пользователя и со временем генерировать интерфейс, который идеально ему подходит.

### **Технические Вызовы и Как их Решить:**

1.  **Скорость Генерации:** Генерация изображений — медленный процесс. Мы не можем генерировать весь UI каждый кадр.
    *   **Решение: Кэширование.** Мы генерируем изображения для каждого состояния виджета (`Idle`, `Hovered`, `Pressed`) **один раз**, когда тема меняется, и складываем их в кэш. Метод `draw` будет просто брать готовую картинку из кэша. Новая генерация нужна только при смене темы или стиля.

2.  **Консистентность (Единообразие Стиля):** Как сделать так, чтобы все кнопки, поля ввода и панели выглядели так, как будто они из одного мира?
    *   **Решение: Общий "Seed" и Промпт.** Мы можем использовать один и тот же "seed" (зерно для генерации) и добавлять общую часть в промпт для всех элементов.
        *   **Базовый промпт:** `"стиль - темный киберпанк, неоновое свечение, основной цвет - синий"`
        *   **Промпт для кнопки:** `+ "нарисуй кнопку с текстом 'Submit', состояние - idle"`
        *   **Промпт для инпута:** `+ "нарисуй поле для ввода текста, состояние - в фокусе"`

3.  **Распознавание Текста:** Как нейросеть нарисует именно тот текст, который нам нужен?
    *   **Решение 1 (Простой):** Мы генерируем **фон** для кнопки, а текст рисуем поверх него нашим старым методом. Это самый надежный способ.
    *   **Решение 2 (Сложный):** Использовать модели, которые умеют хорошо врисовывать текст в изображение (например, DeepFloyd-IF или новые версии Midjourney/DALL-E).


1.  **создали "Пустой Холст".** Самое главное, что мы сделали — это избавились от всех посредников. У нас нет браузера, нет системных виджетов, нет ничего между нашим кодом и массивом пикселей на экране. Это дает нам абсолютную свободу, которая **критически необходима** для AI-рендеринга. Ты не можешь попросить стандартную кнопку Windows "нарисовать себя в стиле стимпанк". А мы можем.

2.  **Мы Разделили "Что" и "Как".** Наша архитектура уже идеально подходит для твоей идеи.
    *   **"Что" (`main.rs`, `ui/mod.rs`):** Этот код решает, *что* должно быть на экране. "Здесь кнопка с ID=0, она сейчас в состоянии `Pressed`". "Здесь текстовое поле, оно в фокусе". Это логика.
    *   **"Как" (`ui/widgets.rs`):** Этот код решает, *как* это нарисовать. Сейчас он рисует примитивные прямоугольники. Но этот модуль — это просто "драйвер" для отрисовки.

3.  **Дорога к AI-Render Engine:**
    Чтобы превратить наш проект в то, что ты задумал, нам нужно всего лишь **заменить реализацию метода `.draw()` в наших виджетах.**

    *   **Было (`widgets.rs`):**
        ```rust
        fn draw(&self, ...) {
            // Нарисовать синий прямоугольник
            // Нарисовать белый текст
        }
        ```

    *   **Станет (концепт):**
        ```rust
        fn draw(&self, ...) {
            // 1. Сформировать промпт: "кнопка 'Submit', состояние Hovered, стиль киберпанк"
            // 2. Проверить, есть ли такая картинка в кэше.
            // 3. Если нет - сгенерировать через AI и положить в кэш.
            // 4. Взять картинку из кэша.
            // 5. "Впечатать" картинку в главный буфер кадра.
        }
        ```
