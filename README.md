# Shadowin

Самодостаточное десктопное приложение на Rust с полностью кастомным графическим интерфейсом (GUI), отрисованным с нуля.

## О проекте

Shadowin — это эксперимент и доказательство концепции, что можно создать полнофункциональное, интерактивное десктопное приложение на чистом Rust, не полагаясь на тяжелые фреймворки (такие как Electron) или стандартные системные виджеты.

Основная философия проекта — **полный контроль**. Мы управляем каждым пикселем на экране. Весь интерфейс, от кнопок до полей ввода текста, является просто визуальным представлением внутреннего состояния приложения. Мы не используем готовые UI-компоненты; вместо этого мы рисуем их сами, используя графические примитивы.

Это позволяет создавать уникальные, быстрые и кроссплатформенные приложения, где вся логика — от обработки клика мыши до рендеринга текста — написана на безопасном и производительном языке Rust.

## Ключевые особенности

*   **Полностью кастомный рендеринг:** Все виджеты отрисовываются пиксель за пикселем в буфер кадра. Нет зависимости от системных UI-библиотек.
*   **Модульная архитектура UI:** Логика интерфейса разделена на три уровня:
    1.  **Главный цикл (`main.rs`):** Управляет окном, событиями и состоянием.
    2.  **UI-менеджер (`ui/mod.rs`):** Содержит и управляет всеми виджетами.
    3.  **Виджеты (`ui/widgets.rs`):** Индивидуальные UI-элементы, которые знают, как себя рисовать и обновлять.
*   **Управление состоянием:** Интерфейс является прямым отражением структуры `AppState`. Изменение данных в `AppState` немедленно отражается на экране при следующей перерисовке.
*   **Самописная библиотека виджетов:** Включает в себя:
    *   `Button`: Интерактивная кнопка с состояниями `Idle`, `Hovered`, `Pressed`.
    *   `TextInput`: Поле для ввода текста с управлением фокусом, вводом символов, Backspace и мигающим курсором.
    *   `TextPanel`: Панель для отображения динамического текста.
*   **Обработка событий:** Реализована полная обработка событий мыши (движение, клики) и клавиатуры (ввод текста, специальные клавиши).
*   **Корректная обработка координат:** Система правильно преобразует физические координаты окна в логические координаты нашего холста, что позволяет интерфейсу работать корректно при любом размере окна.

## Запуск проекта

1.  **Установите Rust:** Если у вас его нет, установите с помощью `rustup`.
2.  **Добавьте шрифт:**
    *   Создайте папку `assets` в корневой директории проекта.
    *   Поместите в нее любой шрифт в формате `.ttf` и переименуйте его в `font.ttf`.
3.  **Запустите:** В терминале, в корневой директории проекта, выполните команду:
    ```bash
    cargo run
    ```

## Архитектура кода

### `main.rs`

Это точка входа и сердце приложения. Его обязанности:
1.  **Инициализация:** Создает окно (`winit`), настраивает графический контекст для рисования (`pixels`) и загружает ресурсы (шрифт).
2.  **Управление состоянием:** Создает и владеет `AppState` — структурой, которая хранит все данные приложения (координаты мыши, текст, счетчики и т.д.).
3.  **Главный цикл событий (`event_loop`):**
    *   Прослушивает все системные события: движение мыши, клики, нажатия клавиш, изменение размера окна.
    *   Обновляет `AppState` на основе этих событий.
    *   Делегирует обработку UI-логики модулю `Ui`.
    *   Запрашивает перерисовку окна, когда это необходимо.

### `ui/mod.rs`

Это "мозг" нашего интерфейса.
1.  **Структура `Ui`:** Является контейнером для всех виджетов (кнопок, полей ввода и т.д.).
2.  **Инициализация UI:** В методе `Ui::new` создаются и размещаются все виджеты.
3.  **Делегирование:** Содержит методы, которые вызываются из `main.rs`:
    *   `handle_click()`: Определяет, по какому виджету кликнули, и управляет фокусом.
    *   `update_visuals()`: Обновляет визуальное состояние виджетов (например, эффект наведения на кнопку).
    *   `handle_key_event()`: Передает события клавиатуры активному полю ввода.
    *   `draw()`: Вызывает методы отрисовки для каждого виджета.

### `ui/widgets.rs`

Это "строительные блоки" нашего интерфейса.
1.  **Определение виджетов:** Здесь определены структуры для каждого виджета (`Button`, `TextInput`, `TextPanel`).
2.  **Внутренняя логика:** Каждый виджет инкапсулирует свою логику:
    *   **Состояние:** Хранит свое внутреннее состояние (например, `ButtonState` или `is_focused`).
    *   **Отрисовка:** Имеет метод `.draw()`, который знает, как нарисовать себя на экране в зависимости от своего текущего состояния.
    *   **Обновление:** Имеет методы для обновления своего состояния на основе ввода пользователя.

## Принцип работы (цикл кадра)

1.  **События:** `main.rs` получает пачку системных событий. Если это клик мыши, он немедленно вызывает `ui.handle_click()`, который обновляет фокус и возвращает ID нажатой кнопки. Логика приложения в `main.rs` реагирует на этот ID и изменяет данные в `AppState`.
2.  **Ожидание (`AboutToWait`):** Когда все события обработаны, вызывается этот блок. Здесь мы:
    *   Получаем актуальные координаты мыши.
    *   Вызываем `ui.update_visuals()`, чтобы все кнопки и другие элементы обновили свой внешний вид (например, подсветились под курсором).
    *   Вызываем `window.request_redraw()`, чтобы сообщить системе, что мы готовы рисовать новый кадр.
3.  **Отрисовка (`RedrawRequested`):**
    *   Система вызывает этот блок.
    *   Мы очищаем экран, заливая его фоновым цветом из `AppState`.
    *   Мы вызываем `ui.draw(&app_state, ...)` одним вызовом.
    *   `Ui` последовательно вызывает `.draw()` для каждого своего виджета.
    *   Каждый виджет рисует себя, используя данные из `AppState` (например, текст) и свое внутреннее состояние (например, цвет нажатой кнопки).
    *   Готовый кадр отправляется на экран.

Этот цикл повторяется непрерывно, создавая иллюзию живого, отзывчивого интерфейса.